CR .( ++++ eForth btc x86 core words  cell=32 ++++ )
\ ==============================================================
\ todo
\ ==============================================================
\ 20110204 bee init DP WORDLIST from COLD
\ 20110125 bee move io
\ 20110121 bee move optimizations
\ 20110118 jwr add E4SIZE E4ORG
\ 20090726 bee move !IMAGE to eforth.f  fix !IO @IO
\ 20070916 bee add CODE-VERSION  split out code.lib.e4
\ 20070725 bee back to EXIT  'XT! CHARS C! C@
\ 20070724 bee remove EXIT use 0 token
\ 20070517 bee char=8 cell=32
\ 20070516 bee add char=8 cell=32 to CHARS CELLS
\ 20070516 bee add 1+ 1-  fix CHAR+ CHAR-
\ 20070511 bee add ATTRIBUTE&  add optimizations
\ 20070423 bee separate code and list

\ ==============================================================
\ 8086 register usage
  \ flags     the direction bit must normally be cleared. CLD
  \ SI        IP Interpreter  Pointer  DS:SI
  \ BP        RP Return stack Pointer  SS:BP builds up
  \ SP        SP data Stack   Pointer  SS:SP builds down
  \ CS=DS=SS  segment registers
  \ ES        free
  \ DI        free  ES:DI
  \ AX        free
  \ BX        free
  \ CX        free
  \ DX        free

\ ==============================================================

CR .( System equates )

H# 8000 EQU E4SIZE    \ size in cells  model with only 32k
H# 0100 EQU E4ORG     \ cell address   eforth .com origin

D#  128 EQU #RP       \ size in cells  return stack
D#   64 EQU #SP       \ size in cells  data stack

D#    8 EQU #VOCS     \ size in cells  vocabulary stack depth

D#   80 EQU #PAD      \ size in chars  PAD floats above HERE
D#  128 D# 2 + H# 010 NEGATE AND H# 010 + \ round up
        EQU nTIB      \ size in chars  input buffer 128+2

H# 040 EQU =COMP      \ attribute COMPILE-ONLY bit
H# 080 EQU =IMED      \ attribute IMMEDIATE bit
H# 03F EQU ATTRIBUTE& \ attribute AND mask

D#    8 EQU =BS       \ backspace character
D#   10 EQU =LF       \ line feed character
D#   13 EQU =CR       \ carrage return character
D#   27 EQU =ESC      \ escape character
D#   32 EQU =BL       \ space character

\ D#  1200 EQU =MSA   \ MilliSecond Adjust  300Mhz Celeron
\ D#  1800 EQU =MSA   \ MilliSecond Adjust  500Mhz Celeron
  D#  7300 EQU =MSA   \ MilliSecond Adjust 1600Mhz Intel T2300

CR .( Memory allocation )

\ |---h>-pad>---<u\r>--<s\tib>-|
E4SIZE nTIB CHARS NEGATE + \ end of memory, allocate down
     H# 010 NEGATE AND     \ H# 010 align
     H# 0FFFF      AND     \ limit to 16bit address space
        DUP EQU =TIB       \ terminal input buffer
        DUP EQU =SP        \ data stack, builds down
#SP CELLS -                \ allocate data and return stacks
#RP CELLS - EQU =RP        \ return stack, builds up

\ ==============================================================

CR .( System entry point )

E4ORG ORG
PROC RESET
  ahead  ALIGN

LABEL =DP     H# 0 , H# 0 ,        \ COLD init HERE MARKER
LABEL =LAST   H# 0 , H# 0 , H# 0 , \ COLD init WORDLIST
HERE =DP - EQU #DP

lABEL VRESET  H# 0 , \ boot vector
LABEL =COLD   H# 0 , \ COLD vector
LABEL =HAND   H# 0 , \ console i/o

LABEL =ioa \ io array \ use ALLOT for sp2
LABEL =rx?    D# 1 CELLS ALLOT \ key?
LABEL =tx?    D# 1 CELLS ALLOT \ emit
LABEL =echo   D# 1 CELLS ALLOT \ echo
LABEL =.cr    D# 1 CELLS ALLOT \ .cr
LABEL =.ok    D# 1 CELLS ALLOT \ .ok
LABEL =pacer  D# 1 CELLS ALLOT \ pacer
LABEL =ibuf   D# 1 CELLS ALLOT \ input buffer
LABEL =obuf   D# 1 CELLS ALLOT \ output buffer
HERE =ioa - EQU #ioa \ ioa size

  then   VRESET [] jmp
END-CODE

CR .( Interpreter ) CR

H# 0000 [IF] \ exit = zero

CODE EXIT ( -- (R a -- )( 6.1.1380 ( 0x33 ) H# 0 XT! END-CODE CR

PROC EXITT \ bbb
LABEL _exit                 \ from next, and boot
  D# 0 rp [] ip mov         \ unnest, restore ip
  D# 1 CELLS ## rp sub      \ post-decrement rp
  begin
LABEL next_xt               \ from next, and boot
    D# 0 ip [] ax mov       \ fetch next token
    D# 2 ip [] dx mov
    D# 1 CELLS ## ip add    \ post-increment ip
LABEL exec_xt               \ from EXECUTE
      ax ax or              \ 0 token is EXIT
    _exit z= ~ until
    LISTBIT' ## dx and      \ token to address
  z= ~ while                \ list token ?
    D# 1 CELLS ## rp add    \ pre-increment rp
    ip D# 0 rp [] mov       \ nest ip
    D# 0 ## D# 2 rp [] mov  \ clear high 16bits \ fake32
    ax ip mov               \ start new list
  repeat  ax jmp            \ execute code

[ELSE] \ exit = exit

CODE EXIT ( -- (R a -- )( 6.1.1380 ( 0x33 )
  D# 0 rp [] ip mov         \ unnest, restore ip
  D# 1 CELLS ## rp sub      \ post-decrement rp
  begin
LABEL next_xt               \ from next, and boot
    D# 0 ip [] ax mov       \ fetch next token
    D# 2 ip [] dx mov
    D# 1 CELLS ## ip add    \ post-increment ip
LABEL exec_xt               \ from EXECUTE
    LISTBIT' ## dx and      \ token to address
  z= ~ while                \ list token ?
    D# 1 CELLS ## rp add    \ pre-increment rp
    ip D# 0 rp [] mov       \ nest ip
    D# 0 ## D# 2 rp [] mov  \ clear high 16bits \ fake32
    ax ip mov               \ start new list
  repeat  ax jmp            \ execute code

[THEN]

LABEL boot
  cli                       \ disable interrupt
  cs bx mov  bx ds mov      \ ds=cs
  bx ss mov  bx es mov      \ ss=cs es=cs
  =SP ## sp mov             \ init SP
  =RP ## rp mov             \ init RP
  sti                       \ enable interrrupts
\ ==============================================================
  RESET ## dx mov
  H# 02523 ## ax mov        \ MS-DOS ^C output interrupt
  H# 021 int
\ ==============================================================
  =COLD ## ip mov           \ first word to execute
  next_xt jmp               \ start interpreting
  boot VRESET !             \ init boot vector
END-CODE

CODE EXECUTE ( xt -- )( 6.1.1370 ( 0x1D )
  ax pop dx pop  exec_xt jmp
END-CODE

CR .( Return stack ) CR

CODE RP@ ( -- a )
  dx dx xor  dx push rp push  next, \ fake32
END-CODE

CODE RP! ( a -- )
  rp pop dx pop  next, \ fake32
END-CODE COMPILE-ONLY

CODE R@ ( -- n (R n -- n )( 6.1.2070 ( 0x32 )
  D# 2 rp [] push  D# 0 rp [] push  next,
END-CODE

CODE >R ( n -- (R -- n )( 6.1.0580 ( 0x30 )
  D# 1 CELLS ## rp add  D# 0 rp [] pop  D# 2 rp [] pop  next,
END-CODE COMPILE-ONLY

CODE R> ( -- n (R n -- )( 6.1.2060 ( 0x31 )
  D# 2 rp [] push  D# 0 rp [] push  D# 1 CELLS ## rp sub  next,
END-CODE COMPILE-ONLY

CR .( Address Units ) CR

CODE CELL- ( a -- a )
  ax pop dx pop  D# 1 CELLS ## ax sub
  D# 0 ## dx sbb  dx push ax push  next,
END-CODE

CODE CELL+ ( a -- a )( 6.1.0880 ( 0x65 )
  ax pop dx pop  D# 1 CELLS ## ax add
  D# 0 ## dx adc  dx push ax push  next,
END-CODE

CODE CELLS ( n -- n )( 6.1.0890 ( 0x69 )
  ax pop dx pop
  D# 1 ## ax shl  D# 1 ## dx rcl ( 2* )
  D# 1 ## ax shl  D# 1 ## dx rcl ( 2* )
  dx push ax push  next,
END-CODE

CODE CHAR- ( a -- a )
  ax pop dx pop  D# 1 CHARS ## ax sub
  D# 0 ## dx sbb  dx push ax push  next,
END-CODE

CODE CHAR+ ( a -- a )( 6.1.0897 ( 0x62 )
  ax pop dx pop  D# 1 CHARS ## ax add
  D# 0 ## dx adc  dx push ax push  next,
END-CODE

D# 0001 CHARS D# 0001 = [IF]

CODE CHARS ( n -- n )( 6.1.0898 ( 0x66 ) \ char=8
  next,
END-CODE IMMEDIATE

[ELSE]

CODE CHARS ( n -- n )( 6.1.0898 ( 0x66 ) 'XT! CELLS \ char=32
END-CODE

[THEN]

CR .( Memory Access ) CR

CODE ! ( n a -- )( 6.1.0010 )
  bx pop cx pop   D# 0 bx [] pop  D# 2 bx [] pop  next, \ fake32
END-CODE

CODE @ ( a -- n )( 6.1.0650 )
  bx pop cx pop
  D# 2 bx [] push  D# 0 bx [] push  next, \ fake32
END-CODE

D# 0001 CHARS D# 0001 = [IF]

CODE C! ( n a -- )( 6.1.0850 ) \ char=8
  bx pop cx pop   ax pop dx pop
  al D# 0 bx [] mov  next, \ fake32
END-CODE

CODE C@ ( a -- n )( 6.1.0870 ) \ char=8
  bx pop cx pop   ax ax xor ax push \ fake32
  D# 0 bx [] al mov  ax push  next,
END-CODE

[ELSE]

CODE C! ( n a -- )( 6.1.0850 ) 'XT! ! \ char=32
END-CODE

CODE C@ ( a -- n )( 6.1.0870 ) 'XT! @ \ char=32
END-CODE

[THEN]

CODE AU! ( c a -- ) \ address units
  bx pop cx pop   ax pop dx pop
  al D# 0 bx [] mov  next, \ fake32
END-CODE

CODE AU@ ( a -- c ) \ address units
  bx pop cx pop   ax ax xor ax push \ fake32
  D# 0 bx [] al mov  ax push  next,
END-CODE

CR .( Literal & Branch ) CR

\ do not separate _ELSE _IF
CODE _ELSE ( -- )( 0x13 ) \ absolute branch
  begin
    D# 0 ip [] ip mov  next,  \ 0==: [ip] -> ip \ fake32
END-CODE COMPILE-ONLY
CODE _IF ( f -- )( 0x14 ) \ absolute branch
    ax pop dx pop  dx ax or
  z= ~ until
  D# 1 CELLS ## ip add  next, \ 0<>: ip+ -> ip \ fake32
END-CODE COMPILE-ONLY

CR .( Data stack ) CR

CODE SP@ ( -- a )
  sp ax mov  dx dx xor  dx push ax push  next, \ fake32
END-CODE

CODE SP! ( a -- )
  sp pop  next, \ fake32
END-CODE

CODE DROP ( n -- )( 6.1.1260 ( 0x46 )
  ax pop dx pop  next,
END-CODE

CODE OVER ( n1 n2 -- n1 n2 n1 )( 6.1.1990 ( 0x48 )
  ax pop dx pop   bx pop cx pop
  cx push bx push   dx push ax push   cx push bx push  next,
END-CODE

CODE DUP ( n -- n n )( 6.1.1290 ( 0x47 )
  ax pop dx pop
  dx push ax push   dx push ax push   next,
END-CODE

CODE SWAP ( n1 n2 -- n2 n1 )( 6.1.2260 ( 0x49 )
  ax pop dx pop   bx pop cx pop
  dx push ax push   cx push bx push  next,
END-CODE

CR .( ALU ) CR

CODE 0< ( n -- f )( 6.1.0250 ( 0x36 )
  ax pop ax pop  cwd  dx push dx push  next,
END-CODE

CODE AND ( n n -- n )( 6.1.0720 ( 0x23 )
  ax pop dx pop   bx pop cx pop
  bx ax and  cx dx and   dx push ax push  next,
END-CODE

CODE XOR ( n n -- n )( 6.1.2490 ( 0x25 )
  ax pop dx pop   bx pop cx pop
  bx ax xor  cx dx xor   dx push ax push  next,
END-CODE

CODE OR ( n n -- n )( 6.1.1980 ( 0x24 )
  ax pop dx pop   bx pop cx pop
  bx ax or  cx dx or   dx push ax push  next,
END-CODE

CODE UM+ ( u u -- ud )
  ax pop dx pop   bx pop cx pop
  bx ax add  cx dx adc   dx push ax push
  D# 0 ## ax mov ax push  ax ax adc ax push  next,
END-CODE

CODE BYE ( -- )( 15.6.2.0830 )
  H# 020 int \ terminate process
END-CODE

LABEL =CODE-VERSION ," x86-32:20110205"

